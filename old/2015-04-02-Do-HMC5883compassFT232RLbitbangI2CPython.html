<html>
<head>
	<title>Dennis Salzner - 2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython</title>
    <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
  <!-- stats -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//dennissalzner.de/stats/matomo/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
  <!-- stats -->
</head>

<body>

<h1>Dennis Salzner - 2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython</h1>
<link rel="image_src" href="grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/004t.jpg" />

<p align="right" style="font-size:80%">
	<a href="../"><< Back Home</a> 
</p>
			
<table style="width:100%">
	<tr>
		<td style="vertical-align: top;">
			<a href="#null" onclick="newWindow('grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/001.jpg','','640','480','')">
				<img src="grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/001t.jpg" width="160" height="107">
			</a>
			<p style="font-size:75%; margin-top: 0;">
				Fig.1: Assembly
			</p>
			
			<a href="#null" onclick="newWindow('grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/002.png','','640','480','')">
				<img src="grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/002t.png" width="160" height="78">
			</a>
			<p style="font-size:75%; margin-top: 0;">
				Fig.2: Oscilloscope pattern
			</p>
			
			<a href="#null" onclick="newWindow('grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/003.jpg','','640','480','')">
				<img src="grafiken/2015-04-02-Do-HMC5883compassFT232RLbitbangI2CPython/003t.jpg" width="160" height="114">
			</a>
			<p style="font-size:75%; margin-top: 0;">
				Fig.3: Compass values at different orientations
			</p>
			
		</td>
		<td style="vertical-align: top;">
			<!-- Titel -->
			<h2>
				Reading the HMC5883 compass module via I2C from Python using an FTDI FT232RL in BitBang-Mode
			</h2>
			<h4>
			A method for connecting a compass module to a computer via USB using only an FTDI chip, 4 wires, 2 resistors and a single Python script
			</h4>
			
			<ul style="font-size:80%">
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#i2cbackground">How I2C works</a></li>
				<li><a href="#connectingthemodule">Connecting the HMC5883 compass module with the FTDI</a></li>
				<li><a href="#pythonftdibitbanging">Setting up Python FTDI bit-banging</a></li>
				<li><a href="#readingthecompass">Python code to read the compass via I2C</a></li>
			</ul>
			
			<!-- Was -->
			<a name="introduction"></a> 
			<p align="right" style="font-size:60%">What?</p>
			<p style="font-size:80%">
				I've written code to read out the HMC5883 compass module via I2C using an FTDI FT232RL in BitBang-Mode.
				<br><br>
				There are FTDI chips with the "Multi-Protocol Synchronous Serial Engine" (MPSSE). These chips can speak I2C and SPI protocols natively, but they are also more expensive. 
				<br>
				Microcontrollers can be programmed to speak I2C, but then software needs to be written for the microcontroller. Also a protocol for communicating with the computer needs to be thought up. Then there has to be another programm running on the computer which talks to the microcontroller. This seems cumbersome, if all you want to do is read a value from your computer.
				<br>
				So I decided to use the FTDI FT232RL. This chip does not support MPSSE, but I can put it into bit-bang mode and write to its ports directly from a single Python programme running on the computer. I can make it speak I2C in software from there. There are disadvantages: This is very slow. But it's sufficient for reading out a compass module, which hardly moves and is slow anyhow. The same goes for temperature sensors, relay boards, analog/digital converters which read values that change slowly - i.e. potentiometers to make simple analog usb input devices - or i2c pwm controllers for servo motors. And no custom code running on the hardware! Python is cross-plattform, so this code will work in Windows, MacOs and Linux.
				<br><br>
				A Python programme such as this one can be combined with Python Flask for making an easy web interface, which can be used to read values or change settings on the local network or the internet even. And the programme could be copied to an embedded computer such as the BeagleboneBlack or RaspberryPi using the same FTDI via the USB port without modifications. And that way there is no need for a client and server software and protocol to handle the communications, as the webserver in Python Flask will do all of this. Python is also very handy for data analysis, plotting and has native support for SQL databases.
			</p>
			<!-- Wann -->
			<p align="right" style="font-size:60%">When?</p>
			<p style="font-size:80%">
				I've spent the past two days trying to get this to work right, until I finally had it running. I started with the PCA9685 PWM driver I want to use for controlling servo motors in another project, but it takes quite a few transactions until the chip actually does anything. So I decided to try to get the HMC5883 compass module to work first. Then I could use the i2c code, which I then know works, for the PCA9685.
			</p>
			<!-- Warum -->
			<p align="right" style="font-size:60%">Why?</p>
			<p style="font-size:80%">
				There is a project I'm working on from time to time. It's a WiFi enabled robot which is, some day, supposed to drive around in my appartment autonomously.
				I want to be able to tell it where to drive, i.e. to the kitchen. This will happen either via software or speech commands.
				<br><br>
				The robot will have a map in order to decide how to get to its destination. But to do this, it needs to be aware of where it is currently located.
				<br><br>
				This amounts to a very tough indoor localisation problem. Positioning systems such as GPS don't work indoors.
				But there are other ways to localise indoors:
			</p>
				<ul style="font-size:80%">
					<li>One can monitor WiFi signal strengths of routers nearby, but this is inaccurate, because the signals bounce off of walls.</li>
					<li>Another way is to measure the rotations of the robots wheels and compute the robots displacement, while driving. But this doesn't work so well due to wheel slippage.
				This method is also very easily fooled when the robot is manually picked up and placed to another location.</li>
					<li>Acceleration sensors are another inaccurate way of computing the robots displacement.</li>
					<li>Measuring the distance of the robot to walls is also possible (by laser or ultra sound), but usually there is furnature or other obsticales in the way. Perhaps even moving obsticales.</li>
					<li>There is also the possibility of analyzing video from a camera mounted on the robot. Software can detect characteristics in the image i.e. edges and match them against a database of known locations.</li>
				</ul>
			<p style="font-size:80%">
				In short: there are many ways and most of them perform very poorly. A viable solution, however, is to combine multiple methods. And this is what I want to try with my robot.
				But to do this: I need many many sensors. And therefore I need to read out sensors such as the HMC5883 compass module. Many sensor modules use the i2c protocol for reading out the values, so I know this code is going to come in very handy.
			</p>
				
			<!-- Hintergrund -->
			<p align="right" style="font-size:60%">Background?</p>
			<p style="font-size:80%">
				 <a name="i2cbackground"></a> 
				<b>I2C background</b>
				<br><br>
			
				I2C is actually quite easy, once you wrap your head around how it works. The aim is to be able to transfer a byte of data (8 bit) to and from slave devices. These devices each have adresses, so they can be daisy chained along two wires without getting mixed up. One of these wires is for the clock signal and one for the data signal. The data signal is read when the clock signal changes. This is also why a slow master device such as the FT232RL, which I use, usually still work - unless the slave restricts the time for transactions, but most don't. The clock signals are slower, but the the data signals come synchronously to the clock signals, anyhow.
				<br><br>
				In order to write, the master has to do the following:
			</p>
				<ul style="font-size:80%">
					<li>1. Send a start sequence indicating the intention to write to the bus. The slaves begin listening after this sequence.</li>
					<li>2. Send the 7 bit address of the slave device. Now all the other slaves stop listening and only the one slave, which was adressed, will continue listening.<br>
					The 8th bit after the 7 bit slave address indicates whether the master wants to write to or read from the slave device. This bit is set to write.<br>
					The slave will respond with one bit, acknowledging or not. If it does not acknowledge this can either mean the slave isn't connected or the address is wrong
					<li>3. So now the slave knows the master is talking to it and all the other slaves have stopped listening and won't interfere. The slave is also prepeared to receive a byte. This next byte indicates which register we would like to write to. And will be acknowledged by the slave.</li>
					<li>4. And then we send another byte, which contains the data which we want to write to that register. Which will also be acknowledged.</li>
					<li>5. The master finished by sending the stop sequence</li>
				</ul>
				<p style="font-size:80%">
				And in order to read, the master has to do this:
				</p>
				<ul style="font-size:80%">
					<li>1. Send a start sequence.</li>
					<li>2. Send the 7 bit address of the slave device. The 8th bit set to write, because we are writing the register address we want to read later. Slave acknowledges.</li>
					<li>3. Send a byte the register address we would like to read from. Slave acknowledges.</li>
					<li>4. Send another start sequence.</li>
					<li>5. Send the 7 bit address of the slave device. The 8th bit set to read this time, because now we want to read. Slave acknowledges.</li>
					<li>6. Change the clock line 8 times and read the bits the slave transmits inbetween. Then the master has to acknowledge.</li>
					<li>7. And send the stop sequence</li>
				</ul>
			<p style="font-size:80%">
				Many slaves also support the "auto-increment feature". That is, if you continue reading by changing the clock line another 8 times, after acknowledging, the slave will automatically select and transfer the next register and so on.
				<br><br>
				This comes in handy when you are reading 16 bit values and you need the first 8 bits and then the last 8 bits, without sending register addresses for subsequent registers every time.
				<br><br>
				So how do I know this? There are two important documents: The "UM10204 I2C-bus specification and user manual" for I2C in general and the HMC5883 compass module datasheet. But these only helped me to come to a general idea. I learn quicker by looking at other peoples source codes. So I checked out the arduino i2c libraries, the adafruit i2c libraries, raspberrypi code, avr code and so on - until I was able to build my own. And an oscilloscope proved very very necessary. I had the FTDI in the wrong mode at first, I was shifting bits in the wrong order, I was shifting too many or too little bits, I was missing the right moment for reading, I had wrong resistors connected, I missed the right moment for switching the io pin from read to write, I was accidentally sending inverted signals and there were quite a lot of other issues - you really need an oscilloscope to sort them out.
			
			<!-- Wie -->
			<p align="right" style="font-size:60%">How?</p>
			<p style="font-size:80%">
				<a name="connectingthemodule"></a> 
				<b>Connecting the module</b>
				<br><br>
				
				I've connected the HMC5883 compass module to the FTDI FT232RL directly. The clock line of the compass module is connected to the TXD line of the FTDI. The data line is connected to the RXD line. I'm using 1.8 kOhm Resistors as pull-ups. These are connected from both lines to Vcc. The breakout board I use for the FT232RL provides a jumper for 3,3V or 5V operation. This jumper is set to 3,3V - the compass module can't handle 5V! The compass Vcc and the pull-ups are also connected to the 3,3V line of the FT232RL. Ground goes to Ground.
				
				<br><br>
				<a name="pythonftdibitbanging"></a> 
				<b>Setting up Python for FTDI bit-banging</b>
				<br><br>
				Bit-banging is the process of programmatically changing the input/output pins. This has to work beforehand and can be verified by measuring the pins or connecting an LED. Setting this up differs between Windows und Linux.
				<br><br>
				On Windows:
				</p>
				<ul style="font-size:80%">
					<li>1. Download and install Python 2.7 32-Bit. (I assume 64-Bit Python will not work due to the 32-Bit libftdi library, but I have not tested this!)</li>
					<li>2. Install pylibftdi via the command prompt by issuing: "pip install pylibftdi"</li>
					<li>3. Download and extract libftdi1-1.0_devkit_mingw32_17Feb2013</li>
					<li>4. Copy "_ftdi1.pyd" and "ftdi1.py" from "libftdi1-1.0_devkit_mingw32_17Feb2013\python2.7\site-packages" to "C:\Python27\Lib\site-packages"</li>
					<li>5. Copy "libftdi1.dll" and "libusb-1.0.dll" to the location of python.exe (or to "Windows\System32" (on 32-Bit Windows) or "Windows\SysWow64" (on 64-Bit Windows))</li>
					<li>6. Connect the FTDI. Windows will automatically download drivers - the wrong drivers. Let it finish then download and run "zadig_v2.0.1.160"
					<br>
					Select "List all Devices" from the menu. Select the FTDI device from the drop down list. Then select "libusbK" instead of "WinUsb" and click on replace.<br>
					The Windows device manager should show the ftdi as a libusbK device now.</li>					
				</ul>
				<p style="font-size:80%">
				On Linux:
				</p>
				<ul style="font-size:80%">
					<li>1. Download and install Python via your distributions package manager</li>
					<li>2. Install pylibftdi via the terminal by issuing: "pip install pylibftdi"</li>
					<li>3. Install libftdi via the package manager</li>
					<li>6. Connect the FTDI. Verify this by running "lsusb"</li>
					<li>It will now work, but only with administrator rights. In order to changes this (I have not tested this!), add:
					
					
<div class="highlight"><pre><span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;usb&quot;</span>, ATTRS<span class="o">{</span>idVendor<span class="o">}==</span><span class="s2">&quot;0403&quot;</span>, ATTRS<span class="o">{</span>idProduct<span class="o">}==</span><span class="s2">&quot;6010&quot;</span>, <span class="nv">MODE</span><span class="o">=</span><span class="s2">&quot;0664&quot;</span>, <span class="nv">GROUP</span><span class="o">=</span><span class="s2">&quot;plugdev&quot;</span>
</pre></div>

				to
<div class="highlight"><pre>
vi /etc/udev/rules.d/99-libftdi.rules 
</pre></div>
				and make sure your user is in the group "plugdev":

<div class="highlight"><pre>
usermod -a -G plugdev <span class="o">[</span>username<span class="o">]</span>
</pre></div>				
					</li>
					
				</ul>
				<p style="font-size:80%">
				The pins on the FTDI should be pulled to high, when running the following Python code:
				</p>
				
				<div class="highlight"><pre><span class="kn">from</span> <span class="nn">pylibftdi</span> <span class="kn">import</span> <span class="n">BitBangDevice</span>
<span class="n">bb</span> <span class="o">=</span> <span class="n">BitBangDevice</span><span class="p">()</span>
<span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b11111111</span>
</pre></div>
				<p style="font-size:80%">
				And to low, when this code is run:
				</p>
				
<div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">pylibftdi</span> <span class="kn">import</span> <span class="n">BitBangDevice</span>
<span class="n">bb</span> <span class="o">=</span> <span class="n">BitBangDevice</span><span class="p">()</span>
<span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000000</span>
</pre></div>

				<p style="font-size:80%">
				The bits in the port byte correspond to the pins of the chip like so:
				</p>
				
				<pre>
bit no		pin name
0		txd
1		rxd
2		rts
3		cts
4		dtr
5		dsr
6		dcd
7		ri
				</pre>
				
				<p style="font-size:80%">
				<a name="readingthecompass"></a> 
				<b>Reading the compass</b>
				<br><br>
				Reading the values is now "just" a matter of setting the clock and data lines to match the i2c specification and that of the compass module. It took me quite some time to get that right (see Fig.2), but the result is Python code which is no longer than 200 lines and handles it all. The code could be shortend by removing the debug options, the comments and adding an i2cread function, but I think it's more human-readable this way:
				
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199</pre></div></td><td class="code"><div class="highlight"><pre>
<span class="c">2015-04-02 D.Salzner</span>

<span class="kn">from</span> <span class="nn">pylibftdi</span> <span class="kn">import</span> <span class="n">BitBangDevice</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">bb</span> <span class="o">=</span> <span class="n">BitBangDevice</span><span class="p">()</span>

<span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">PIN_0_TXD</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">PIN_1_RXD</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">PIN_I2C_SCL</span> <span class="o">=</span> <span class="n">PIN_0_TXD</span>
<span class="n">PIN_I2C_SDA</span> <span class="o">=</span> <span class="n">PIN_1_RXD</span>

<span class="c"># --- gpio ---</span>
<span class="k">def</span> <span class="nf">pout</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="n">wert</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">wert</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pin</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pin</span><span class="p">)</span>
	<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pin</span><span class="p">(</span><span class="n">pin</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">bb</span><span class="o">.</span><span class="n">port</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">pin</span><span class="p">):</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">pinit</span><span class="p">():</span>
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SCL</span><span class="p">)</span> <span class="c"># Clock aus Ausgang</span>
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># SDA als Ausgang</span>

<span class="c"># --- i2c ---</span>
<span class="k">def</span> <span class="nf">i2cstart</span><span class="p">():</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">i2cstop</span><span class="p">():</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">i2cwrite</span><span class="p">(</span><span class="n">wert</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;[S: &quot;</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span> <span class="c"># Rueckwaerts rausshiften</span>
		<span class="k">if</span><span class="p">(</span><span class="n">wert</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">):</span>
			<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">)</span>
		
		<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="n">wert</span> <span class="o">=</span> <span class="n">wert</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>

	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># als Eingang</span>
	
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">ack</span> <span class="o">=</span> <span class="n">pin</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ack</span><span class="p">))</span>	<span class="c"># ist 0, wenn der Slave acknowledged. sonst 1 - da wir den Pin auf 1 gelassen haben.</span>
	
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># wieder als Ausgang</span>
	
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
	
	<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span> <span class="c"># bisschen entzerren, damit am Oszi leichter lesbar</span>

<span class="c"># --- HMC5883 ---</span>
<span class="n">chipAddress</span> <span class="o">=</span> <span class="mh">0x3C</span>
<span class="k">print</span> <span class="n">format</span><span class="p">(</span><span class="n">chipAddress</span><span class="p">,</span> <span class="s">&#39;#010b&#39;</span><span class="p">)</span>
	
<span class="k">def</span> <span class="nf">hmc5883init</span><span class="p">():</span>
	<span class="c"># Startsequenz</span>
	<span class="n">i2cstart</span><span class="p">()</span>
	
	<span class="c"># Chip ansprechen und Write vorbereiten</span>
	<span class="n">ersten8</span> <span class="o">=</span> <span class="n">chipAddress</span>
	<span class="n">ersten8</span> <span class="o">=</span> <span class="n">ersten8</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># read/write auf 0, zum schreiben</span>
	<span class="n">i2cwrite</span><span class="p">(</span><span class="n">ersten8</span><span class="p">)</span> <span class="c"># erwarte danach 0 als ack</span>
	
	<span class="c"># Modus Register auswaehlen</span>
	<span class="n">i2cwrite</span><span class="p">(</span><span class="mh">0x02</span><span class="p">)</span> <span class="c"># erwarte danach 0 als ack</span>
	
	<span class="c"># und kontinuierliche Messung reinschreiben</span>
	<span class="n">i2cwrite</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="c"># erwarte danach 0 als ack</span>
	
	<span class="c"># Abschliessen</span>
	<span class="n">i2cstop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">hmc5883lesen</span><span class="p">(</span><span class="n">register</span><span class="p">):</span>
	<span class="n">i2cstart</span><span class="p">()</span>
	
	<span class="c"># Chip ansprechen und Write vorbereiten</span>
	<span class="n">ersten8</span> <span class="o">=</span> <span class="n">chipAddress</span>
	<span class="n">ersten8</span> <span class="o">=</span> <span class="n">ersten8</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># read/write auf 0, zum schreiben</span>
	<span class="n">i2cwrite</span><span class="p">(</span><span class="n">ersten8</span><span class="p">)</span> <span class="c"># erwarte danach 0 als ack</span>
	
	<span class="c"># Register anwaehlen</span>
	<span class="n">i2cwrite</span><span class="p">(</span><span class="n">register</span><span class="p">)</span> <span class="c"># erwarte danach 0 als ack</span>
	
	<span class="n">i2cstart</span><span class="p">()</span>
	
	<span class="c"># und jetzt lesen vorbereiten... i2c_rep_start</span>
	<span class="n">ersten8</span> <span class="o">=</span> <span class="n">chipAddress</span>
	<span class="n">ersten8</span> <span class="o">=</span> <span class="n">ersten8</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># read/write auf 1, zum lesen</span>
	<span class="n">i2cwrite</span><span class="p">(</span><span class="n">ersten8</span><span class="p">)</span> <span class="c"># erwarte danach 0 als ack</span>
	
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;[L: &quot;</span><span class="p">)</span>
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># als Eingang</span>
		
	<span class="n">msb</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span> <span class="c"># eigl 8 - danach kommen die naechsten 8 des Wertes</span>
		<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		
		<span class="n">msb</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pin</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
			<span class="n">msb</span> <span class="o">|=</span> <span class="mh">0x1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">)</span>
	
		<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;]&quot;</span><span class="p">)</span>
	
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># wieder als Ausgang</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># ich muss acknowledgen...</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># als Eingang</span>
	
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;[L: &quot;</span><span class="p">)</span>
	
	<span class="n">lsb</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span> <span class="c"># eigl 8 - danach kommen die naechsten 8 des Wertes</span>
		<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		
		<span class="n">lsb</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pin</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
			<span class="n">lsb</span> <span class="o">|=</span> <span class="mh">0x1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">)</span>
	
		<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
	
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># wieder als Ausgang</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SDA</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># ich muss acknowledgen...</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">pout</span><span class="p">(</span><span class="n">PIN_I2C_SCL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">direction</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PIN_I2C_SDA</span><span class="p">)</span> <span class="c"># als Eingang</span>
	
	<span class="c"># Abschliessen</span>
	<span class="n">i2cstop</span><span class="p">()</span>
	
	<span class="n">wert</span> <span class="o">=</span> <span class="p">((</span><span class="n">msb</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">lsb</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">wert</span>

<span class="n">pinit</span><span class="p">()</span>
<span class="n">hmc5883init</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
	<span class="c"># Messungen holen</span>
	<span class="k">if</span> <span class="n">debug</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">print</span> <span class="s">&quot;x&quot;</span>
	
	<span class="n">x</span> <span class="o">=</span> <span class="n">hmc5883lesen</span><span class="p">(</span><span class="mh">0x03</span><span class="p">)</span> <span class="c"># Register 3, von der x-Komponente die vordersten Bits auswaehlen</span>
	<span class="n">y</span> <span class="o">=</span> <span class="n">hmc5883lesen</span><span class="p">(</span><span class="mh">0x05</span><span class="p">)</span>
	<span class="n">z</span> <span class="o">=</span> <span class="n">hmc5883lesen</span><span class="p">(</span><span class="mh">0x07</span><span class="p">)</span>
	
	<span class="k">print</span> <span class="s">&quot;x: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; </span><span class="se">\t</span><span class="s"> y: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; </span><span class="se">\t</span><span class="s"> z: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
	<span class="k">print</span> <span class="s">&quot;-----&quot;</span>
	
	<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</table>		
			</p>
</p>
			<!-- Fortschritt -->
			<p align="right" style="font-size:60%">Progress?</p>
			<p style="font-size:80%">
				The module is fully working and the values change when moving it as expected (Fig.3). The next step could be to compute an angle from the value and calibrate it to display a compass needle pointing north.
				<br><br>
				I will be using the code to speak with other I2C devices - especially the PWM driver.
			</p>
		</td>
	</tr>
</table>

<!-- -------------------------------------------------------------------------------------- -->
<script type="text/javascript" language="JavaScript">
// Centered Pop-Up Window (v1.0)
// (C) 2002-2005 www.smileycat.com
// Free for all users, but leave in this header</code><br>

var win = null;
function newWindow(mypage,myname,w,h,features) {
  var winl = (screen.width-w)/2;
  var wint = (screen.height-h)/2;
  if (winl = 0) winl = 0;
  if (wint = 0) wint = 0;
  var settings = 'height=' + h + ',';
  settings += 'width=' + w + ',';
  settings += 'top=' + wint + ',';
  settings += 'left=' + winl + ',';
  settings += features;
  win = window.open(mypage,myname,settings);
  win.window.focus();
}
</script>

</body>
</html>
